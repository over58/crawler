# 1、什么是回溯算法（Back-Track Algorithm）
## 1.1、思想
回溯法从根节点出发，按照深度优先策略遍历解空间树，搜索满足约束条件的解。在搜索至树中任一节点时，先判断该节点对应的部分解是否满足约束条件/是否超出目标函数的限界，也就是判断该节点是否包含问题的（最优）解，如果肯定不包含，则跳过对以该节点为根的子树的搜索（即所谓的剪枝），逐层向其根节点回溯；否则，进入以该节点为根的子树，继续按照深度优先策略搜索。当回溯到根，且根节点的所有子树都已被访问过才结束。
回溯算法通常使用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
❝

找到一个可能存在的正确答案在尝试了所有可能的分步方法后宣告失败该问题没有答案
❞
回溯法采用试错的思想，它尝试分步去解决一个问题，可以系统的找到一个问题的所有解或任意解。在最坏的情况下，回溯法将导致一次复杂度为指数级的计算。
## 1.2、解决思路
解决一个回溯问题，实际上就是一个决策树的遍历过程，你需要思考 3 个问题
❝

路径：也就是已经做出的选择。选择列表：也就是你当前可以做的选择。结束条件：也就是到达决策树底层，无法再做选择的条件（约束条件/是否超出目标函数的界）。
❞
# 2、代码模板
result = []def backtrack(路径, 选择列表):    if 满足结束条件:        result.add(路径)        return    for 选择 in 选择列表:        做选择 // 前序遍历位置        // 进入下一层决策树（explore）        backtrack(路径, 选择列表) // 中序遍历位置        撤销选择 // 后序遍历位置：回退上一节点复制代码
其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，类似二叉树的遍历，关键就是在前序遍历和后序遍历的位置做一些操作。

作者：Yerlang
链接：https://juejin.cn/post/6855129007823061006
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。